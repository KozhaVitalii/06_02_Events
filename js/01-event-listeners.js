/*
 * События.
 * - Создание и удаление слушателей
 * - Именование колбеков для слушателей
 *    - handle*: handleSubjectEvent
 *    - *Handler: subjectEventHandler
 *    - on*: onSubjectEvent
 * - Ссылочная идентичность колбеков
 * - Объект события
 */

// События - это реакция браузера на какое-то действие пользователя (движение или клик мышки, нажатие клавиши
// на клавиатуре, начало и конец анимации, просмотр видео и т.д).

// Разберем пример:
// У нас в HTML файле создана разметка на три кнопки, первая целевая кнопка, вторая при нажатии на которую
// происходит добавление слушателя на целевую(первую кнопку), при нажатии на третью происходит снятие
// слушателя:
//     <button type="button" class="js-target-btn">Целевая кнопка</button>
    // <button type="button" class="js-add-listener">Добавить слушатель</button>
    // <button type="button" class="js-remove-listener">Снять слушатель</button>

// const targetBtn = document.querySelector('.js-target-btn'); //  создана ссылка на целеую кнопку в разметке.
// // Ссылка через класс "js-target-btn"(см пред.лекцию)

// const addListenerBtn = document.querySelector('.js-add-listener'); // создана ссылка на вторую кнопку в разметке.
// const removeListenerBtn = document.querySelector('.js-remove-listener'); // создана ссылка на третью кнопку в разметке.

// Повесим на неё слушатель событий:

// targetBtn.addEventListener('click', () => {
//   console.log('Клик');
// });

// в() первым аргументом мы передаем тип события на который мы хотим реагировать(прослушивать), обычно "click"
// передается это событие в виде 'строки', вторым аргументом передаем колбэк функцию которая будет выполнена в
// момент наступления этого события. Подписка разумеется выполняется на том элементе, на котором происходит
// событие.

// Со списком всех возможных событий можно ознакомиться по ссылке:
// https://developer.mozilla.org/ru/docs/Web/Events

// Разберем как правильно передавать колбэки

// ('click',() => {
//   console.log('Клик');
// }); // такая функция является анонимной функцией.

// Если мы хотим сохранить функцию и сделать её внешней, а потом вызывать через колбэк, нам необходимо её
// правильно именовать.

//  * - Именование колбеков для слушателей
//  *    - handle*: handleSubjectEvent
//  *    - *Handler: subjectEventHandler
//  *    - on*: onSubjectEvent

// Первый способ наименования:
// Сначала пишется handle а потом указывается тип события, в нашем случае это "клик", поэтому так:

// function handleClick () {
//   console.log('Клик');
// };

// Проблема такого наименования в том, что оно слишком общее. Поэтому лучше уточнять:
// * Handler: handleSubjectEvent

// function handleButtonClick или handleTargetButtonClick

// Второй способ "*Handler: subjectEventHandler":

// Eventhandler

// function clickHandler () {
//   console.log('Клик');
// }; //  также слишком общее поэтому лучше:

// function targetButtonClickHandler () {
//   console.log('Клик');
// };

// Третий способ: - on*: onSubjectEvent:

// function onTargetButtonClick () {
//   console.log('Клик');
// };

// Важно чтобы на проектах использовалси один из этих методов. Но в рамках проекта только один выбранный метод

// Напишем анонимную функцию:
targetBtn.addEventListener('click', () => {
  console.log('Клик по кнопке');
});

// Для удобства продублируем выше написанные переменные:
const targetBtn = document.querySelector('.js-target-btn'); //  создана ссылка на целеую кнопку в разметке.
// Ссылка через класс "js-target-btn"(см пред.лекцию)

const addListenerBtn = document.querySelector('.js-add-listener'); // создана ссылка на вторую кнопку в разметке.
const removeListenerBtn = document.querySelector('.js-remove-listener'); // создана ссылка на третью кнопку в разметке.

// Напишем ещё две функции, первая добавляет слушателя на целевую кнопку, вторая снимает слушателя с неё:


// addListenerBtn.addEventListener('click', () => {
// console.log('Вешаю слушателя события на целевую кнопку');

//   targetBtn.addEventListener('click', () => {
//        console.log('Клик по целевой кнопке');
//     });
// });

// Распишем что происходит в вышеописанной функции:
// Когда мы кликаем по кнопке addListenerBtn у нас в консоль выводится сообщение:
// 'Вешаю слушателя события на целевую кнопку', это происходит потому что мы на неё повесили слушатель событий:
// addListenerBtn.addEventListener('click'), т.е.браузер отслеживает клик и выводит, то что мы прописали в теле
// функции, а именно наше сообщение(это первый этап).Далее, благодаря тому что в тело функции вложена ещё одна
// функция: targetBtn.addEventListener('click', () => { console.log('Клик по целевой кнопке'); }); на целевую
// кнопку вешается слушатель событий(мы эту фнкцию прописывали выше, в данном примере, мы используем
// вложенность функций, первая и основная выводит сообщение для той кнопки кторая кликается, на вторую кнопку
// вешается слушатель).

// Теперь напишем функцию, которая снимает слушателя на события(в реальных юзкейсах эти две функции
// используется к примеру для подписки и отписки на рассылку новостей):

// свойство "removeEventListener" - снимает слушателя событий.

// removeListenerBtn.addEventListener('click', () => {
// console.log('Снимаю слушателя события с целевой кнопки');

//   targetBtn.removeEventListener('click', () => {
//        console.log('Клик по целевой кнопке');
//     });
// });

// Мы видим, что в результате такой записи, у нас не происходит снятие слушателя с целевой кнопки.Почему ?
// Потому что мы в первой(добавить) и во второй(снять) функции использовали вложенную функцию на целевую
// кнопку:

// targetBtn.removeEventListener('click', () => {
//        console.log('Клик по целевой кнопке');
//     });

// По своей сути это две разные анонимные функции. Напомню, что функция это объект, который хранится в ячейке
// памяти.Наши анонимные функции по сути это абсолютно разные ячейки в памяти, которые хранят в себе ссылки на
// оригинальную функцию описанную в строках 90 - 92. В итоге эти функции не равны друг другу, это не одна и та
// же функция, что и в строках 90 - 92. Это просто две разные её копии, а значит они живут своей независимой
// жизнью.
// Соответственно, для того чтобы наши две кнопки, которые вешают и снимаю слушателя на целевую кнопку,
// срабатывали корректно, нам необходимо:
 
// все наши хендлеры(о которых мы говорили выше) выносить во внешние функции, и после чего просто передается
// везде одна ссылка на эту функцию (но уже именную) и это называется - ссылочная идентичность колбеков.

// В итоге для того чтобы:
// targetBtn.removeEventListener('click', () => { console.log('Клик по целевой кнопке'); }); стала одной и 
// той же функцией(на всякий лучай уточню что в этой записи 
// функция это вот эта часть: () => { console.log('Клик по целевой кнопке'); }).Мы пишем одну функцию, которая
// будет подставлятся в targetBtn.removeEventListener('click', ссылка на функцию), на место второй параметра:

// 1. Создаем функцию:
// function onTargetBtnClick() {
//   console.log('Клик по целевой кнопке');
// }

// 2. Ссылаемся на неё подставляя во второй параметр функции:

// addListenerBtn.addEventListener('click', () => {
// console.log('Вешаю слушателя события на целевую кнопку');

//   targetBtn.addEventListener('click', onTargetBtnClick);
// });

// removeListenerBtn.addEventListener('click', () => {
//   console.log('Снимаю слушателя события с целевой кнопки');

//   targetBtn.removeEventListener('click', onTargetBtnClick);
// });

// Теперь все работает!!!

// Ок, что ещё? Каждый из колбеков (хендлеров событий), вот эта часть () =>, он получает некий event (событие)
// т.е. объект событий.Когда происходит событие, браузер генерит его и собирает в какие то объекты(в JS это
// представлено обычным объектом) и этот объект приходит обязательно парамтром в эти "() =>" колбек функции,
// а имено в (). Мы можем назвать это событие (параметр) как угодно, к примеру "event". Он подставиться во
// все три функции: 

// addListenerBtn.addEventListener('click', (event) => {
// console.log('Вешаю слушателя события на целевую кнопку');

//   targetBtn.addEventListener('click', onTargetBtnClick);
// });

// removeListenerBtn.addEventListener('click', (event) => {
//   console.log('Снимаю слушателя события с целевой кнопки');

//   targetBtn.removeEventListener('click', onTargetBtnClick);
// });

// // И сюда передастся тоже:
// function onTargetBtnClick(event) {
//   console.log('Клик по целевой кнопке');
// }
// Потому что onTargetBtnClick мы передали как колбэк и в addListenerBtn и в removeListenerBtn, а значит
// в него прийдёт event обязательно.

// В нашем случае этим событием будет являться: MouseEvent.Если мы в одной из наших функций это законсолим
// console.log(event); то мы увидем это событие MouseEvent, на котором будет очень много разных свойств.
// Основные из которых разберем чуть дальше.

// Добавим console.log(event) в каждую из функций, чтобы посмотреть как это событие выглядит и какие у
// него есть свойства на каждой функции:

addListenerBtn.addEventListener('click', event => {
  console.log(event);
  console.log('Вешаю слушателя события на целевую кнопку');

  targetBtn.addEventListener('click', onTargetBtnClick);
});

removeListenerBtn.addEventListener('click', event => {
  console.log(event);
  console.log('Снимаю слушателя события с целевой кнопки');

  targetBtn.removeEventListener('click', onTargetBtnClick);
});

function onTargetBtnClick(event) {
  console.log(event);
  console.log('Клик по целевой кнопке');
}
